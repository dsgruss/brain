syntax = "proto3";

// Convenience structures for defining current patching states and connections

enum PatchState {
    // Enum used to track a global state over all connected modules

    IDLE = 0;  // No buttons pushed across all modules
    PATCH_ENABLED = 1;  // One single button pushed
    PATCH_TOGGLED = 2;  // Two buttons pushed, consisting of an input and output
    BLOCKED = 3; // Three or more buttons pushed or two of the same type
}

message HeldInputJack {
    string uuid = 1;
    string id = 2;
}

message HeldOutputJack {
    string uuid = 1;
    string id = 2;
    int32 color = 3;
    string addr = 4;
    int32 port = 5;
}

message LocalState {
    repeated HeldInputJack held_inputs = 1;
    repeated HeldOutputJack held_outputs = 2;
}

message PatchConnection {
    string input_uuid = 1;
    string input_jack_id = 2;
    string output_uuid = 3;
    string output_jack_id = 4;
}

// Patch update and preset handling messages

message Update {
    string uuid = 1;
    LocalState local_state = 2;
}

message SnapshotRequest {
    string uuid = 1;
}

message SnapshotResponse {
    string uuid = 1;
    bytes data = 2;
    repeated PatchConnection patched = 3;
}

message SetPreset {
    string uuid = 1;
    repeated SnapshotResponse data = 2;
}

message SetInputJack {
    string uuid = 1;
    HeldOutputJack source = 2;
    PatchConnection connection = 3;
}

message Halt {
    string uuid = 1;
}

// Leader election and state sync

message Heartbeat {
    string uuid = 1;
    int32 term = 2;
    int32 iteration = 3;
}

message HeartbeatResponse {
    string uuid = 1;
    int32 term = 2;
    bool success = 3;
    int32 iteration = 4;
    LocalState state = 5;
}

message GlobalStateUpdate {
    string uuid = 1;
    PatchState patch_state = 2;
    HeldInputJack input = 3;
    HeldOutputJack output = 4;
}

message RequestVote {
    string uuid = 1;
    int32 term = 2;
}

message RequestVoteResponse {
    string uuid = 1;
    int32 term = 2;
    string voted_for = 3;
    bool vote_granted = 4;
}

// Directives are multicast, so message type is determined at runtime

message Directive {
    oneof directive {
        Update update = 1;
        SnapshotRequest snapshot_request = 2;
        SnapshotResponse snapshot_response = 3;
        SetPreset set_preset = 4;
        SetInputJack set_input_jack = 5;
        Halt halt = 6;
        Heartbeat heartbeat = 7;
        HeartbeatResponse heartbeat_response = 8;
        GlobalStateUpdate global_state_update = 9;
        RequestVote request_vote = 10;
        RequestVoteResponse request_vote_response = 11;
    }
}